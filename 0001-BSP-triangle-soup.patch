From cecd5bfe20affad5db173925a73ceda849f10709 Mon Sep 17 00:00:00 2001
From: Paril <paril@alteredsoftworks.com>
Date: Thu, 27 Oct 2016 12:32:28 -0400
Subject: [PATCH] BSP triangle soup! Notes: skybox and materials still render
 with TRIANGLE_FAN to prevent re-calculating vertex positions and stuff on the
 CPU + since they're copied locally to be worked with.

---
 src/client/renderer/r_bsp.c         |  2 +-
 src/client/renderer/r_bsp_model.c   | 68 ++++++++++++++++++++++++++-----------
 src/client/renderer/r_bsp_surface.c |  2 +-
 src/client/renderer/r_material.c    | 32 ++++++++---------
 src/client/renderer/r_sky.c         |  6 ++--
 src/client/renderer/r_types.h       |  1 +
 6 files changed, 71 insertions(+), 40 deletions(-)

diff --git a/src/client/renderer/r_bsp.c b/src/client/renderer/r_bsp.c
index 4d95d00..8d4bf91 100644
--- a/src/client/renderer/r_bsp.c
+++ b/src/client/renderer/r_bsp.c
@@ -328,7 +328,7 @@ void R_DrawBspLeafs(void) {
 			if ((*s)->vis_frame != r_locals.vis_frame)
 				continue;
 
-			R_DrawArrays(GL_TRIANGLE_FAN, (*s)->index, (*s)->num_edges);
+			R_DrawArrays(GL_TRIANGLES, (*s)->index, (*s)->num_elements);
 		}
 	}
 
diff --git a/src/client/renderer/r_bsp_model.c b/src/client/renderer/r_bsp_model.c
index e1985af..7df3d1e 100644
--- a/src/client/renderer/r_bsp_model.c
+++ b/src/client/renderer/r_bsp_model.c
@@ -470,8 +470,9 @@ static void R_LoadBspSurfaces(r_bsp_model_t *bsp, const d_bsp_lump_t *l) {
 		// and size, texcoords, etc
 		R_SetupBspSurface(bsp, out);
 
-		// make room for elements
-		out->elements = Mem_LinkMalloc(sizeof(GLuint) * out->num_edges, bsp);
+		// make room for triangles
+		out->num_elements = (out->num_edges - 2) * 3;
+		out->elements = Mem_LinkMalloc(sizeof(GLuint) * out->num_elements, bsp);
 
 		// lastly lighting info
 		const int32_t ofs = LittleLong(in->light_ofs);
@@ -739,19 +740,23 @@ static GLuint R_LoadBspVertexArrays_VertexElement(GLuint *vertex_index) {
 /**
  * @brief Writes vertex data for the given surface to the load model's arrays.
  *
- * @param elements The current element count for the load model.
- * @param vertices The current unique vertex count for the load model.
+ * @param num_elements The current element count for the load model.
+ * @param num_vertices The current unique vertex count for the load model.
  */
-static void R_LoadBspVertexArrays_Surface(r_model_t *mod, r_bsp_surface_t *surf, GLuint *elements, GLuint *vertices) {
+static void R_LoadBspVertexArrays_Surface(r_model_t *mod, r_bsp_surface_t *surf, GLuint *num_elements, GLuint *num_vertices) {
 
-	surf->index = *elements;
+	surf->index = *num_elements;
 
 	const int32_t *e = &mod->bsp->surface_edges[surf->first_edge];
 
-	for (uint16_t i = 0; i < surf->num_edges; i++, e++) {
+	// these are initialized to -1 since it's never going
+	// to be this value legally.
+	GLuint first_index = (GLuint) -1, last_index = (GLuint) -1;
+
+	for (uint16_t i = 0, element = 0; i < surf->num_edges; i++, e++) {
 		const r_bsp_vertex_t *vert = R_BSP_VERTEX(mod->bsp, *e);
 
-		VectorCopy(vert->position, mod->bsp->verts[*vertices]);
+		VectorCopy(vert->position, mod->bsp->verts[*num_vertices]);
 
 		// texture directional vectors and offsets
 		const vec_t *sdir = surf->texinfo->vecs[0];
@@ -767,8 +772,8 @@ static void R_LoadBspVertexArrays_Surface(r_model_t *mod, r_bsp_surface_t *surf,
 		vec_t t = DotProduct(vert->position, tdir) + toff;
 		t /= surf->texinfo->material->diffuse->height;
 
-		mod->bsp->texcoords[*vertices][0] = s;
-		mod->bsp->texcoords[*vertices][1] = t;
+		mod->bsp->texcoords[*num_vertices][0] = s;
+		mod->bsp->texcoords[*num_vertices][1] = t;
 
 		// lightmap texture coordinates
 		if (surf->flags & R_SURF_LIGHTMAP) {
@@ -785,8 +790,8 @@ static void R_LoadBspVertexArrays_Surface(r_model_t *mod, r_bsp_surface_t *surf,
 			t /= surf->lightmap->height * mod->bsp->lightmaps->scale;
 		}
 
-		mod->bsp->lightmap_texcoords[*vertices][0] = s;
-		mod->bsp->lightmap_texcoords[*vertices][1] = t;
+		mod->bsp->lightmap_texcoords[*num_vertices][0] = s;
+		mod->bsp->lightmap_texcoords[*num_vertices][1] = t;
 		
 		// normal vector, which is per-vertex for SURF_PHONG
 
@@ -796,19 +801,44 @@ static void R_LoadBspVertexArrays_Surface(r_model_t *mod, r_bsp_surface_t *surf,
 		else
 			normal = surf->normal;
 
-		VectorCopy(normal, mod->bsp->normals[*vertices]);
+		VectorCopy(normal, mod->bsp->normals[*num_vertices]);
 
 		// tangent vectors
 		vec4_t tangent;
 		vec3_t bitangent;
 
 		TangentVectors(normal, sdir, tdir, tangent, bitangent);
-		Vector4Copy(tangent, mod->bsp->tangents[*vertices]);
+		Vector4Copy(tangent, mod->bsp->tangents[*num_vertices]);
 
 		// find the index that this vertex belongs to.
-		surf->elements[i] = R_LoadBspVertexArrays_VertexElement(vertices);
-		(*elements)++;
+		GLuint vertex_id = R_LoadBspVertexArrays_VertexElement(num_vertices);
+
+		// we're compiling triangles here and converting from a fan.
+		// for the first 3 elements, just add them as-is.
+		// they provide the "seed triangle". index 0 is first_index, and
+		// index 2 will be the first "last_index" 
+
+		if (i < 3) {
+			if (i == 0)
+				first_index = vertex_id;
+			else if (i == 2)
+				last_index = vertex_id;
+
+			surf->elements[element++] = vertex_id;
+		}
+		else {
+			// we have more than 3 added to the elements list, so 
+			// now for each vertex we're creating a new triangle.
+			// surf->index is the first element ID, so every
+			// new triangle is (surf->index, last_index, element)
+			// and last_index becomes element.
+			surf->elements[element++] = first_index;
+			surf->elements[element++] = last_index;
+			last_index = surf->elements[element++] = vertex_id;
+		}
 	}
+
+	*num_elements += surf->num_elements;
 }
 
 /**
@@ -877,7 +907,7 @@ static void R_LoadBspVertexArrays(r_model_t *mod) {
 
 	const size_t e = mod->num_elements * sizeof(GLuint);
 	GLuint *elements = Mem_LinkMalloc(e, mod);
-	GLuint ei = 0;
+	GLuint element = 0;
 	
 	leaf = mod->bsp->leafs;
 	for (uint16_t i = 0; i < mod->bsp->num_leafs; i++, leaf++) {
@@ -886,8 +916,8 @@ static void R_LoadBspVertexArrays(r_model_t *mod) {
 		for (uint16_t j = 0; j < leaf->num_leaf_surfaces; j++, s++) {
 
 			r_bsp_surface_t *surf = (*s);
-			for (uint16_t k = 0; k < surf->num_edges; k++, ei++) {
-				elements[ei] = surf->elements[k];
+			for (uint16_t k = 0; k < surf->num_elements; k++, element++) {
+				elements[element] = surf->elements[k];
 			}
 		}
 	}
diff --git a/src/client/renderer/r_bsp_surface.c b/src/client/renderer/r_bsp_surface.c
index 1cfa845..0f3eacc 100644
--- a/src/client/renderer/r_bsp_surface.c
+++ b/src/client/renderer/r_bsp_surface.c
@@ -70,7 +70,7 @@ static void R_SetBspSurfaceState_default(const r_bsp_surface_t *surf) {
  */
 static void R_DrawBspSurface_default(const r_bsp_surface_t *surf) {
 
-	R_DrawArrays(GL_TRIANGLE_FAN, surf->index, surf->num_edges);
+	R_DrawArrays(GL_TRIANGLES, surf->index, surf->num_elements);
 
 	r_view.num_bsp_surfaces++;
 }
diff --git a/src/client/renderer/r_material.c b/src/client/renderer/r_material.c
index 9b949ba..e79b028 100644
--- a/src/client/renderer/r_material.c
+++ b/src/client/renderer/r_material.c
@@ -303,56 +303,56 @@ static void R_SetStageState(const r_bsp_surface_t *surf, const r_stage_t *stage)
  * helper functions, outputting to the default vertex arrays.
  */
 static void R_DrawBspSurfaceMaterialStage(const r_bsp_surface_t *surf, const r_stage_t *stage) {
-	int32_t i;
+	int32_t i, j;
 
-	for (i = 0; i < surf->num_edges; i++) {
+	for (i = 0, j = 0; i < surf->num_elements; i += (i < 2 ? 1 : 3), j++) {
 
 		const vec_t *v = &r_model_state.world->bsp->verts[surf->elements[i]][0];
 		const vec_t *st = &r_model_state.world->bsp->texcoords[surf->elements[i]][0];
 
-		R_StageVertex(surf, stage, v, &r_state.vertex_array[i * 3]);
+		R_StageVertex(surf, stage, v, &r_state.vertex_array[j * 3]);
 
-		R_StageTexCoord(stage, v, st, &texunit_diffuse.texcoord_array[i * 2]);
+		R_StageTexCoord(stage, v, st, &texunit_diffuse.texcoord_array[j * 2]);
 
 		if (texunit_lightmap.enabled) { // lightmap texcoords
 			st = &r_model_state.world->bsp->lightmap_texcoords[surf->elements[i]][0];
-			texunit_lightmap.texcoord_array[i * 2 + 0] = st[0];
-			texunit_lightmap.texcoord_array[i * 2 + 1] = st[1];
+			texunit_lightmap.texcoord_array[j * 2 + 0] = st[0];
+			texunit_lightmap.texcoord_array[j * 2 + 1] = st[1];
 		}
 
 		if (r_state.color_array_enabled) // colors
-			R_StageColor(stage, v, &r_state.color_array[i * 4]);
+			R_StageColor(stage, v, &r_state.color_array[j * 4]);
 
 		if (r_state.lighting_enabled) { // normals and tangents
 
 			const vec_t *n = &r_model_state.world->bsp->normals[surf->elements[i]][0];
-			VectorCopy(n, (&r_state.normal_array[i * 3]));
+			VectorCopy(n, (&r_state.normal_array[j * 3]));
 
 			const vec_t *t = &r_model_state.world->bsp->tangents[surf->elements[i]][0];
-			VectorCopy(t, (&r_state.tangent_array[i * 4]));
+			VectorCopy(t, (&r_state.tangent_array[j * 4]));
 		}
 	}
 
-	R_UploadToBuffer(&r_state.buffer_vertex_array, 0, i * sizeof(vec3_t), r_state.vertex_array);
-	R_UploadToBuffer(&texunit_diffuse.buffer_texcoord_array, 0, i * sizeof(vec2_t), texunit_diffuse.texcoord_array);
+	R_UploadToBuffer(&r_state.buffer_vertex_array, 0, j * sizeof(vec3_t), r_state.vertex_array);
+	R_UploadToBuffer(&texunit_diffuse.buffer_texcoord_array, 0, j * sizeof(vec2_t), texunit_diffuse.texcoord_array);
 
 	if (texunit_lightmap.enabled) { 
 
-		R_UploadToBuffer(&texunit_lightmap.buffer_texcoord_array, 0, i * sizeof(vec2_t), texunit_lightmap.texcoord_array);
+		R_UploadToBuffer(&texunit_lightmap.buffer_texcoord_array, 0, j * sizeof(vec2_t), texunit_lightmap.texcoord_array);
 	}
 
 	if (r_state.color_array_enabled) {
 	
-		R_UploadToBuffer(&r_state.buffer_color_array, 0, i * sizeof(vec4_t), r_state.color_array);
+		R_UploadToBuffer(&r_state.buffer_color_array, 0, j * sizeof(vec4_t), r_state.color_array);
 	}
 
 	if (r_state.lighting_enabled) {
 
-		R_UploadToBuffer(&r_state.buffer_normal_array, 0, i * sizeof(vec3_t), r_state.normal_array);
-		R_UploadToBuffer(&r_state.buffer_tangent_array, 0, i * sizeof(vec4_t), r_state.tangent_array);
+		R_UploadToBuffer(&r_state.buffer_normal_array, 0, j * sizeof(vec3_t), r_state.normal_array);
+		R_UploadToBuffer(&r_state.buffer_tangent_array, 0, j * sizeof(vec4_t), r_state.tangent_array);
 	}
 
-	R_DrawArrays(GL_TRIANGLE_FAN, 0, i);
+	R_DrawArrays(GL_TRIANGLE_FAN, 0, j);
 }
 
 /**
diff --git a/src/client/renderer/r_sky.c b/src/client/renderer/r_sky.c
index b481c10..7abf77c 100644
--- a/src/client/renderer/r_sky.c
+++ b/src/client/renderer/r_sky.c
@@ -237,15 +237,15 @@ static void R_ClipSkySurface(int32_t nump, vec3_t vecs, int32_t stage) {
  */
 static void R_AddSkySurface(const r_bsp_surface_t *surf) {
 	vec3_t verts[MAX_CLIP_VERTS];
-	uint16_t i;
+	uint16_t i, j;
 
 	if (r_draw_wireframe->value)
 		return;
 
 	// calculate distance to surface verts
-	for (i = 0; i < surf->num_edges; i++) {
+	for (i = 0, j = 0; i < surf->num_elements; i += (i < 2 ? 1 : 3), j++) {
 		const vec_t *v = &r_model_state.world->bsp->verts[surf->elements[i]][0];
-		VectorSubtract(v, r_view.origin, verts[i]);
+		VectorSubtract(v, r_view.origin, verts[j]);
 	}
 
 	R_ClipSkySurface(surf->num_edges, verts[0], 0);
diff --git a/src/client/renderer/r_types.h b/src/client/renderer/r_types.h
index 629e053..4acc3d3 100644
--- a/src/client/renderer/r_types.h
+++ b/src/client/renderer/r_types.h
@@ -231,6 +231,7 @@ typedef struct {
 
 	int32_t first_edge; // look up in model->surf_edges, negative numbers
 	uint16_t num_edges; // are backwards edges
+	uint32_t num_elements; // number of elements
 
 	vec3_t mins;
 	vec3_t maxs;
-- 
2.8.1.windows.1

